# Search Layer Configuration
# Controls A* search, heuristics, and beam search parameters

# A* Search settings
astar:
  max_program_length: 4  # K=4 from requirements
  max_nodes_expanded: 600  # ≤600 expanded states target
  max_computation_time: 30.0  # 30 second timeout
  duplicate_detection: true  # Enable duplicate state detection
  early_termination: true  # Enable early termination on exact match
  
# Beam search settings
beam_search:
  initial_beam_width: 32
  adaptive_beam: true
  min_beam_width: 8  # Minimum beam width
  beam_reduction_factor: 0.7  # Factor to reduce beam when needed
  beam_reduction_threshold: 0.5  # Reduce beam when >50% nodes expanded
  
# Heuristic system settings
heuristics:
  # Two-tier heuristic system
  use_tier2: true
  tier2_threshold: 5.0

  # Tier-2 gating (disabled by default to preserve behavior). Enable to reduce slow spikes.
  gating:
    enable: true
    max_blob_for_tier2: 8
    min_depth_for_tier2: 2
    max_tier2_calls: 20
    dedupe_pairs: true
    use_greedy_fallback_when_large: true
  
  # Tier 1: L₂ spectral heuristic
  tier1:
    name: "L2_Spectral"
    max_computation_time: 0.001
    use_d4_minimization: false
    cache_features: true  # Cache feature vectors
    
  # Tier 2: Hungarian assignment heuristic  
  tier2:
    name: "Hungarian_Assignment"
    max_computation_time: 0.005
    use_scipy: true
    fallback_greedy: true
    
# Search strategy settings
strategy:
  # Cost function
  uniform_cost: true  # Each operation costs 1
  prefer_shorter_programs: true  # Tie-breaking prefers shorter programs
  
  # Exploration vs exploitation
  exploration_bonus: 0.0  # No exploration bonus (pure A*)
  
  # Termination conditions
  exact_match_only: false  # Accept approximate solutions
  min_improvement_threshold: 0.1  # Minimum heuristic improvement
  
# Performance monitoring
monitoring:
  track_search_stats: true  # Track detailed search statistics
  log_beam_reductions: true  # Log beam width reductions
  warn_slow_heuristics: true  # Warn on slow heuristic computations
  save_search_tree: false  # Save search tree for debugging (expensive)
  
# Advanced settings
advanced:
  # Node ordering
  tie_breaking_strategy: "cost_then_depth"  # cost < depth for tie-breaking

  # Memory management
  max_memory_usage: 1.0  # Maximum memory usage in GB
  garbage_collect_frequency: 1000  # GC every N node expansions

  # UNSAT cache configuration
  unsat_cache:
    enabled: true  # Enable UNSAT caching for proven impossibilities
    signatures_file: "expanded_unsat_signatures.jsonl"  # Path to JSONL file with pre-computed signatures

  # Program canonicalization configuration
  canonicalization:
    enabled: true  # Enable program canonicalization via rewrite rules
    saturation_enabled: false  # Enable e-graph style saturation (fixed-point)
    validate_smt: false       # Optional SMT validation of rewrites (future)

  # Retrieval persistence (optional)
  retrieval:
    preload_file: "retrieval_store.jsonl"  # JSONL with {signature, program} - same as store_file for reuse
    store_file: "retrieval_store.jsonl"    # Path to append newly found solutions

  # Dead-end predictor configuration
  deadend_predictor:
    enabled: true  # Enable dead-end prediction gating (conservative)
    model_file: "enhanced_deadend_model.json"  # Path to trained dead-end predictor model

  # Pattern database heuristic configuration
  pdb:
    enabled: true  # Enable PDB lower bound in heuristics

  # Debugging
  debug_mode: false  # Enable debug mode (slower)
  save_failed_searches: false  # Save failed searches for analysis

# Portfolio scheduler (optional)
portfolio:
  enabled: true
  budgets:
    retrieval: 0.2       # seconds - increased for real ARC task lookups
    templates: 0.5       # increased for complex pattern matching
    object_level: 0.5    # increased for object manipulation synthesis
    cegis: 0.5           # increased for program synthesis attempts
    astar: 0.0           # rely on searcher internal timeout
    llm_guided: 0.0      # rely on searcher internal timeout
  hazard_scheduling: true   # Reorder lanes by learned hazard/efficiency metrics
  record_metrics: true       # Record lane metrics across runs
  metrics_file: "portfolio_metrics.jsonl"  # JSONL file to append per-task lane metrics
  tie_breaking_strategy: "calibrated_floor"  # Use calibrated value for tie-breaking
